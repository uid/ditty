<style type="text/css">
/*
 * drag the loop from one while into the loop of another while
 * color according to nesting level
 * allow creation of commands by right-click... 'solidifies' the line as a sentence
 * recommend abstraction according to nesting level
 */

table {
  border: outset 5pt;
  border-collapse: separate;
  border-spacing: 5px;
}
td {
  vertical-align: bottom;
  border: inset 5pt;
  padding: 4px;
}

body {
  background: white url(/assets/grid.jpg);
  font-family: "Helvetica Neue", sans-serif;
  padding-bottom: 3000px;
}
div.bubble {
  display: inline-block;
  font-size: 16px;
  line-height: 29px;
  /*vertical-align: baseline;*/
  background: white;
  border: 1px solid #bbb;
  -webkit-border-radius: 10px;
  margin: 4px 2px;
  color: black;
  box-shadow: 1px 1px 1px #aaa;
}
div.bubble.editing {
  background: #eef;
  border: 1px solid #fcc;
  box-shadow: 3px 3px 7px #999;
}
div.bubble.active {
  background: #eef;
  box-shadow: 3px 3px 7px #0f0;
}
div.bubble div.representation {
  padding: 4px;
  background: white;
  -webkit-border-radius: 10px;
  cursor: hand;
}
div.bubble div.representation.editing {
  background: #ccf;
  box-shadow: 1px 1px 3px #000;
}
/*
unfortunately these don't play nice with nesting
div.bubble div.representation:hover {
  background: #ccf;
}
div.bubble div.representation.editing:hover {
  background: #bbe;
}
*/
div.bubble div.meaning {
  color: black;
  display: none;
  padding: 8px;
  /*border-top: 3px solid black;*/
}
div.bubble div.meaning p.stats {
  margin: 0;
  padding: 0;
  font-size: 14px;
  position: relative;
  top: 8px;
}
div.bubble div.meaning textarea {
  display: block;
  overflow: auto;
  width: 400px;
  height: 72px; /* 4px top/bottom padding in my browser */
  font-size: 13px;
  line-height: 16px;
}

div.editor_toolbar {
  display: none;
}
div.editor {
  background: white;
}


div.bubble.reference {
  display: inline;
  padding: 3px 0;
  background: #dfd;
  border: 2px solid #9b9;
  -webkit-border-radius: 5px;
}
div.bubble.reference div.representation {
  display: inline;
  background: transparent;
}


span.slot {
  cursor: hand;
}
span.slot.unfilled {
  padding: 3px;
  background: #fcc;
  border: 2px solid #caa;
  -webkit-border-radius: 5px;
  /*margin: 1px;*/
}
span.slot.drag-hover {
  background: black;
  color: white;
}


ul.multislot {
  margin: 0;
  padding: 0;
  display: inline-block;
  vertical-align: baseline;
}
ul.multislot li {
  list-style-type: none;
}
ul.multislot li.content {
  padding: 0;
  margin: 0;
}
ul.multislot li.inbetweener {
  width: 100%;
  height: 3px;
  position: relative;
  cursor: hand;
}
ul.multislot li.inbetweener .insert {
  width: 20px;
  height: 20px;
  position: absolute;
  top: -8.5px;
  left: -20px;
  display: none;
  text-align: center;
  vertical-align: middle;
  font-size: 18px;
  line-height: 18px;
  background: #66f;
  color: white;
}
ul.multislot li.inbetweener.drag-hover,
ul.multislot li.inbetweener.hover {
  background: #66f;
}
ul.multislot li.inbetweener.not-editing:hover,
ul.multislot li.inbetweener.not-editing:hover .insert {
  color: white;
  background: #006;
}


/* AUTOCOMPLETE */
.ui-autocomplete {
  display: inline-block;
  -webkit-border-bottom-right-radius: 4px;
  -khtml-border-bottom-right-radius: 4px;
  border-bottom-right-radius: 4px;
  border: 1px solid #AAA;
  background: white;
  color: #222;
  z-index: 1 !important;
}
.ui-menu {
  list-style: none;
  padding: 2px;
  margin: 0;
}
.ui-menu .ui-menu {
  margin-top: -3px;
}
.ui-menu .ui-menu-item {
  margin: 0;
  padding: 0;
  border-bottom: 1px solid black;
}
.ui-menu .ui-menu-item a {
  text-decoration: none;
  display: block;
  padding: .1em .2em;
  line-height: 1.5;
}
.ui-menu .ui-menu-item a.ui-state-hover,
.ui-menu .ui-menu-item a.ui-state-active {
  font-weight: normal;
  margin-left: -1px;
  background: black;
  color: white;
}
.ui-menu .ui-menu-item a.ui-state-hover .expression,
.ui-menu .ui-menu-item a.ui-state-active .expression {
  color: black; /* stay black */
}
p.author {
  margin: 0;
  padding: 0;
  font-weight: bold;
  font-size: small;
  font-variant: small-caps;
}


div.trash {
  width: 100px;
  height: 100px;
  background: #ccc;
  text-align: center;
}
</style>
<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jqueryui/1.8.18/jquery-ui.min.js"></script>
<!-- <script type="text/javascript" src="/assets/jquery.js"></script> -->
<!-- <script type="text/javascript" src="/assets/jquery-ui.js"></script> -->
<script type="text/javascript" src="/assets/canvas/util/underscore.js"></script>
<script type="text/javascript" src="/assets/canvas/util/backbone.js"></script>
<script type="text/javascript" src="/assets/canvas/util/backbone-deep-model.js"></script>
<script type="text/javascript" src="/assets/canvas/util/my.class.min.js"></script>
<script type="text/javascript">

// shuffles an array (supposedly Fisher-Yates, but I didn't check)
// adapted from http://snippets.dzone.com/posts/show/849
function shuffle(arr) {
  for(var j, x, i = arr.length; i; j = parseInt(Math.random() * i), x = arr[--i], arr[i] = arr[j], arr[j] = x);
    return arr
}

// returns a random element from the array
function randomPick(arr) {
  return arr[Math.floor(Math.random() * arr.length)]
}

// capitalizes the first letter of a string
function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

// generates an "adjective-noun"-looking random phrase using some goofy rules
function randomPhrase() {
  var cons_syllables = ["kon", "fab", "al", "el", "il", "ol", "ul", "krog", "blug", "kem", "moop", "rad", "korm", "delph", "dib", "kek", "deop", "tok", "mig", "tet", "grep", "loog", "tonk", "garf", "yap", "tulk", "krin", "zid", "nik", "zot", "kob", "xor", "aw", "ew", "iw", "ow", "uw", "ar", "er", "ir", "or", "ur", "at", "et", "it", "ot", "ut", "ay", "ey", "iy", "oy", "uy", "ap", "ep", "ip", "op", "up", "as", "es", "is", "os", "us", "ad", "ed", "id", "od", "ud", "af", "ef", "if", "of", "uf", "ag", "eg", "ig", "og", "ug", "ah", "eh", "ih", "oh", "uh", "ak", "ek", "ik", "ok", "uk", "al", "el", "il", "ol", "ul", "az", "ez", "iz", "oz", "uz", "ax", "ex", "ix", "ox", "ux", "ack", "eck", "ick", "ock", "uck", "av", "ev", "iv", "ov", "uv", "ab", "eb", "ib", "ob", "ub", "an", "en", "in", "on", "un", "am", "em", "im", "om", "um"]
  var first_suffixes = ["ic", "ated", "aceous", "aholic", "atory", "ibant", "arpic", "idic", "inal", "inic", "emic", "ergic", "est", "erous", "ating", "ful", "genic", "iatric", "izating", "itious", "ling", "lithic", "lytic", "merous", "morphic", "morphous", "oic", "parous", "pathic", "phagous", "philiac", "philous", "phobic", "ploid", "scopic", "thermic", "trophic", "tropic", "ular", "wise", "worthy", "wide", "zoic", "zygous"]
  var second_suffixes = ["ator", "izer"]
  
  var randomWord = function(suffixes) {
    var num_syllables = Math.floor(Math.random() * 2) + 1
    shuffle(cons_syllables)
    return cons_syllables.slice(0, num_syllables).join("") + randomPick(suffixes)
  }
  
  return capitalize(randomWord(first_suffixes)) + " " + capitalize(randomWord(second_suffixes))
}

// wraps a jQuery event handler function
// only propagates the event if e.target == e.currentTarget
// (this is false when a click lands on multiple elements and one is on top)
function ifTarget(f) {
  return function(e) {
    if(e.target != e.currentTarget) return
    return f.apply(null /* this */, arguments)
  }
}

var safeClick = function(f) {
  return function(e) {
    if(e.target != e.currentTarget) return
    if(noclick) return
    return f.apply(null /* this */, arguments)
  }
}

// sends a gradient through the background of the given HTML element
// (if color is unspecified, it will be red)
function flash(elem, color) {
  color = color || "red"
  elem = $(elem)
  elem.stop(true /* clear animation queue */, true /* jump to end of animation */)
  elem.css("background", "white url(/assets/" + color + "-gradient.png) repeat-y ")
  elem.css("background-position", "-80px")
  elem.animate(
    { "background-position" : elem.width() },
    { duration: 300, complete: function() { elem.css("background", "") } }
  )
}

</script>
<script type="text/javascript">

// forked from https://gist.github.com/1610397
// creates a collection which forwards all changes back to the given attribute
// if the attribute's array has insertions or deletions, those changes won't be reflected in the collection,
//   though changes to existing items will
Backbone.Model.prototype.nestCollection = function(attributeName, nestedCollection) {
  // for(var i = 0; i < nestedCollection.length; i++) {
  //   this.attributes[attributeName][i] = nestedCollection.at(i).attributes
  // }
  var arr = this.get(attributeName)
  for(var i = 0; i < nestedCollection.length; i++) {
    arr[i] = nestedCollection.at(i).attributes
  }
  nestedCollection.bind("add", function(initiative) {
    // if(!this.get(attributeName)) {
    //   this.attributes[attributeName] = []
    // }
    this.get(attributeName).push(initiative.attributes)
  }.bind(this))
  nestedCollection.bind("remove", function(initiative) {
    this.set({ attributeName: _.without(this.get(attributeName), initiative.attributes) })
  }.bind(this))
  return nestedCollection
}


// maintains template.parameters and template.components
// template.parameters is an array of the names of the parameters (in order of appearance)
// template.components is an array of objects, each like one of these
//   { text: "static text" }
//   { parameter: "name" }
var Template = Backbone.Model.extend({
  defaults: {
    template: ""
  },
  
  initialize: function() {
    this._parse()
    this.bind("change:template", this._parse, this)
  },
  
  _parse: function() {
    this.components = []
    this.parameters = []
    
    var text = this.get("template")
    var result
    var i = 0
    var paramRegexp = /\[([^\]]+)\]/gi
    while((result = paramRegexp.exec(text)) != null) {
      var nonParamText = text.slice(i, paramRegexp.lastIndex - result[1].length - 2)
      if(nonParamText != "")
        this.components.push({ text: nonParamText })
      this.components.push({ parameter: result[1] })
      this.parameters.push(result[1])
      i = paramRegexp.lastIndex
    }
    var nonParamText = text.slice(i)
    if(nonParamText != "")
      this.components.push({ text: nonParamText })
    
    this.text = $("<div />").html(text).text()
  },
})
var TemplateCollection = Backbone.Collection.extend({
  model: Template,
})


var MeaningCollection = Backbone.Collection.extend({
  // monkey-patch _prepareModel to make it polymorphic!
  _prepareModel: function(model, options) {
    if (!(model instanceof Backbone.Model)) {
      if("invocation" in model) {
        model = new Invocation(model["invocation"])
      } else if("reference" in model) {
        model = new ArgumentReference(model["reference"])
      } else if("number" in model) {
        model = new NumberMeaning({ number: model["number"] })
      } else if("boolean" in model) {
        model = new BooleanMeaning({ boolean: model["boolean"] })
      } else if("string" in model) {
        model = new StringMeaning({ string: model["string"] })
      }
    }
    return Backbone.Collection.prototype._prepareModel.call(this, model, options)
  },
  
  compile: function() {
    return this.map(function(m) { return m.compile() })
  },
})


// representations, arguments, meaning
var Pattern = Backbone.Model.extend({
  defaults: function() {
    return {
      representations: [{ template: randomPhrase() }],
      arguments: [],
      show: true,
      complete: false,
    }
  },
  
  initialize: function() {
    this.templates = this.nestCollection("representations", new TemplateCollection(this.get("representations")))
    this.arguments = this.nestCollection("arguments", new ArgumentReferenceCollection(this.get("arguments")))
    
    this._meaningHack()
    if(this.has("native_meaning")) {
      this.native_meaning = this.nestCollection("native_meaning", new MeaningCollection(this.get("native_meaning")))
    } else if(this.has("javascript_meaning")) {
      this.javascript_meaning = this.get("javascript_meaning")
      this.on("change:javascript_meaning", function() { this.javascript_meaning = this.get("javascript_meaning") }, this)
    }
    
    this.templates.on("change", function() {
      this.trigger("change:representations", this, this.templates, { changes: { representations: true } })
      this.trigger("change", this, { changes: { representations: true } })
    }, this)
  },
  
  // TODO!
  isMine: function() {
    return false
  },
  
  _meaningHack: function() {
    if(!this.has("meaning")) return
    var meaning = this.get("meaning")
    if("native_meaning" in meaning) {
      this.set("native_meaning", meaning["native_meaning"])
    } else if("javascript_meaning" in meaning) {
      this.set("javascript_meaning", meaning["javascript_meaning"])
    }
    this.unset("meaning")
  },
  
  getArgument: function(name) {
    return this.arguments.where({ name: name })[0]
  },
  
  compile: function() {
    if(this.native_meaning) {
      return this.native_meaning.map(function(m) { return m.compile() })
    } else if(this.javascript_meaning) {
      return [new VM.IJavascript(this.javascript_meaning)]
    } else {
      throw new Error("this pattern has no meaning")
    }
  },
})

var PatternCollection = Backbone.Collection.extend({
  model: Pattern,
  url: "/patterns",
  
  getByKey: function(key) {
    for(var i in this.models) {
      if(this.models[i].get("key") == key) {
        return this.models[i]
      }
    }
  },
})

// pattern, arguments, representationIndex
var Invocation = Backbone.DeepModel.extend({
  defaults: {
    arguments: {},
    representationIndex: 0,
    expanded: false,
  },
  
  initialize: function() {
    // XXX data munging
    this.attributes["arguments"] || (this.attributes["arguments"] = {})
    this.arguments = {}
    var args = this.get("arguments")
    for(var i in args) {
      if(!_.isArray(args[i])) {
        args[i] = [args[i]]
      }
      this.arguments[i] = this.nestCollection("arguments." + i, new MeaningCollection(args[i]))
    }
    
    // TODO: if pattern has only a client ID, detect when it gets a real ID and save that
    // TODO: prevent upload if the pattern doesn't have a real ID
  },
  
  getPattern: function() {
    if(!this._pattern) {
      var pattern = this.get("pattern")
      if(pattern instanceof Backbone.Model) {
        this._pattern = pattern
      } else {
        this._pattern = Patterns.get(pattern) || Patterns.getByCid(pattern)
        if(!this._pattern) this._pattern = Patterns.getByKey(pattern) // XXX HACK
      }
      
      // XXX do I need this? it would cause every invocation that contains an invocation of the given pattern to be saved
      // this._pattern.on("change", function(pattern, event) {
      //   this.trigger("change:pattern", this, pattern, { changes: { pattern: true } })
      //   this.trigger("change", this, { changes: { pattern: true } })
      // }, this)
    }
    return this._pattern
  },
  
  getCurrentTemplate: function() {
    return this.getPattern().templates.at(this.get("representationIndex"))
  },
  
  // getter which creates an empty value for that argument if there isn't one
  argumentValue: function(name) {
    if(!this.arguments[name]) {
      var arg = this.get("arguments")[name] = []
      this.arguments[name] = this.nestCollection("arguments." + name, new MeaningCollection(arg))
    }
    return this.arguments[name]
  },
  
  compile: function() {
    var args = _.inject(this.arguments, function(args, mc, name) {
      args[name] = mc.compile()
      return args
    }, {})
    return new VM.ICall(this.getPattern().compile(), args)
  },
})

var ArgumentReference = Backbone.Model.extend({
  defaults: {
    name: "",
  },
  
  compile: function() {
    return new VM.INamedReference(this.get("name"))
  },
})
var ArgumentReferenceCollection = Backbone.Collection.extend({ model: ArgumentReference })

var NumberMeaning = Backbone.Model.extend({
  defaults: {
    number: 0,
  },
  
  compile: function() {
    return this.get("number")
  },
  
  getValue: function() { 
    return this.get("number")
  },
})

var BooleanMeaning = Backbone.Model.extend({
  defaults: {
    boolean: false,
  },
  
  compile: function() {
    return this.get("boolean")
  },
  
  getValue: function() {
    return this.get("boolean")
  },
})

var StringMeaning = Backbone.Model.extend({
  defaults: {
    string: "",
  },
  
  compile: function() {
    return this.get("string")
  },
  
  getValue: function() {
    return this.get("string")
  },
})

</script>
<script type="text/javascript">

var DittyMath = {
  distance: function(x1, y1, x2, y2) {
    return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1))
  },
  
  clamp: function(val, min, max) {
    if(val < min) return min
    if(val > max) return max
    return val
  },
}

</script>
<script type="text/javascript">

var dragging = false // whether a drag is taking place
var noclick = false // stays true a little longer after dragging becomes false

var View = {}

// set and get objects associated with dom elements
View.objFor = function(dom) {
  return $(dom).data("obj")
}
View.setObjFor = function(dom, obj) {
  $(dom).data("obj", obj)
}
View.patternAutocomplete = function(input, view, dismiss) {
  // input.focusout(dismiss)
  input.keydown(function(ev) { if(ev.keyCode == 27) { dismiss() } })
    
  input.autocomplete({
    delay: 0,
    autoFocus: true,
    source: function(request, callback) {
      var matches = []
      
      if(/^-?[0-9.]+$/i.exec(request.term)) {
        var view = new View.BasicMeaningView(new NumberMeaning({ number: parseFloat(request.term) }))
        var item = $("<div>number: </div>").append(view.dom)
        matches.push({ value: item, result: view })
      }
      
      if("true".indexOf(request.term) == 0 || "false".indexOf(request.term) == 0) {
        var value = (request.term.indexOf("t") != -1)
        var view = new View.BasicMeaningView(new BooleanMeaning({ boolean: value }))
        var item = $("<div>boolean: </div>").append(view.dom)
        matches.push({ value: item, result: view })
      }
      
      if(true) {
        var view = new View.BasicMeaningView(new StringMeaning({ string: request.term }))
        var item = $("<div>string: </div>").append(view.dom)
        matches.push({ value: item, result: view })
      }
      
      var keywords = request.term.toLowerCase().split(" ")
      var keywordMatches = []
      for(var pid in Patterns.models) {
        if(isNaN(parseFloat(pid))) continue // skip non-numeric keys (they're backward-compatibility dupes)
        var pattern = Patterns.models[pid]
      
        for(var i in pattern.templates.models) {
          var template = pattern.templates.models[i]
          var text = template.text.toLowerCase()
          
          // check that all keywords are present
          var found = true
          var minIndex = 1000
          for(var j in keywords) {
            var index = text.indexOf(keywords[j])
            if(index == -1) {
              found = false
              break
            }
            if(index < minIndex) minIndex = index
          }
          if(found) {
            var dom = $("<div style='position: relative'></div>")
            var view = new View.InvocationView(new Invocation({ pattern: pattern, representationIndex: i }))
            var preventClicksDom = $("<div style='position: absolute; left: 0; top: 0; width: 100%; height: 100%'></div>").appendTo(dom)
            dom.append(view.dom)
            dom.append(preventClicksDom)
            
            // // capture all mouse events before they can get to the view
            // viewContainerDom.get(0).addEventListener('mousedown', function(e) { e.stopPropagation() }, true)
            // viewContainerDom.get(0).addEventListener('mouseup', function(e) { e.stopPropagation() }, true)
            // viewContainerDom.get(0).addEventListener('click', function(e) { e.stopPropagation() }, true)
            
            if(pattern.has("creator")) {
              var creator = pattern.get("creator")
              if(creator.ditty) {
                dom.prepend($("<p class='author'>built-in</p>"))
              } else if(pattern.isMine()) {
                dom.prepend($("<p class='author'>created by <span style='color: blue; text-decoration: underline'>me</span></p>"))
              } else {
                dom.prepend($("<p class='author'>created by " + (creator.readable_name || "anonymous") + "</p>"))
              }
            }
            ;(function(pattern, i, minIndex, view) {
              keywordMatches.push({
                minIndex: minIndex,
                value: dom,
                result: view
              })
            })(pattern, i, minIndex, view)
          }
        }
      }
      keywordMatches.sort(function(a, b) { return a.minIndex - b.minIndex })
      matches.push.apply(matches, keywordMatches)
      
      callback(matches)
    },
    select: function(event, ui) {
      debugger
      var v = ui.item["result"]
      v.dom.detach()
      view.dropped(v)
    },
    open: function() {
      input.data("menuOpen", true);
    },
    close: function() {
      input.data("menuOpen", false);
      if(!input.is(":focus"))
        dismiss()
    }
  }).data("autocomplete")._renderItem = function(ul, item) {
    // copied from jQuery source, but uses 'html' instead of 'text'
    return $("<li></li>").data("item.autocomplete", item).append($("<a></a>").html(item.label)).appendTo(ul)
  }

  input.blur(function() {
    if(!input.data("menuOpen"))
      dismiss()
  })
}

View.draggable = {
  decorate: function(klass) {
    klass.prototype.setParent = View.draggable.setParent
    klass.prototype.droppableEnter = View.draggable.droppableEnter
    klass.prototype.droppableLeave = View.draggable.droppableLeave
  },
  
  draggable: function(obj, dom, options) {
    var opts = {
      cursor: "move",
      opacity: 0.5,
      revert: true,
      revertDuration: 0,
      zIndex: 1,
      start: View.draggable.start.bind(obj),
      drag: View.draggable.drag.bind(obj),
      stop: View.draggable.stop.bind(obj),
    }
    for(var i in options) {
      opts[i] = options[i]
    }
    dom.draggable(opts)
    obj.hovered = []
  },
  
  // fired when a drag begins
  start: function(ev, ui) {
    dragging = true
    noclick = true
  },
  
  // fired as the mouse moves during a drag
  drag: function(ev, ui) {
    var nearest = undefined, dist = 10000
    for(var i in this.hovered) {
      var o = this.hovered[i]
      var rectX = DittyMath.clamp(ev.pageX, o.dom.offset().left, o.dom.offset().left + o.dom.outerWidth())
      var rectY = DittyMath.clamp(ev.pageY, o.dom.offset().top, o.dom.offset().top + o.dom.outerHeight())
      var d = DittyMath.distance(ev.pageX, ev.pageY, rectX, rectY)
      if(d < dist) {
        nearest = o
        dist = d
      }
    }
    if(dist > 15) {
      nearest = undefined
    }
    if(this.currentDragTarget != nearest) {
      if(this.currentDragTarget) {
        this.currentDragTarget.dom.removeClass("drag-hover")
      }
      this.currentDragTarget = nearest
      if(this.currentDragTarget) {
        this.currentDragTarget.dom.addClass("drag-hover")
      }
    }
  },
  
  // fired when a drag completes
  stop: function(ev, ui) {
    if(this.currentDragTarget) {
      if(this.parent) this.parent.dragout(this, this.currentDragTarget)
      this.currentDragTarget.dropped(this)
      this.currentDragTarget.dom.removeClass("drag-hover")
    }
    this.hovered = []
    dragging = false
    setTimeout(function() { noclick = false }, 100)
    this.currentDragTarget = undefined
  },
  
  setParent: function(parent) {
    if(parent == this.parent) return
    if(this.parent) this.parent.release(this)
    this.parent = parent
  },
  
  // called by droppables who are within dropping distance
  droppableEnter: function(droppable) {
    this.hovered.push(droppable)
  },
  
  // called by droppables who are within dropping distance
  droppableLeave: function(droppable) {
    this.hovered = _.without(this.hovered, droppable)
  },
}

View.droppable = {
  droppable: function(obj, dom, options) {
    var opts = {
      tolerance: "touch",
      over: View.droppable.over.bind(obj),
      out: View.droppable.out.bind(obj),
      accept: function(elem) {
        return elem.has(this.dom).length == 0
      }.bind(obj)
    }
    for(var i in options) {
      opts[i] = options[i]
    }
    dom.droppable(opts)
  },
  
  over: function(ev, ui) {
    View.objFor(ui.draggable).droppableEnter(this)
  },
  
  out: function(ev, ui) {
    View.objFor(ui.draggable).droppableLeave(this)
  },
}

View.viewForMeaning = function(meaning) {
  if(meaning instanceof Invocation) {
    return new View.InvocationView(meaning)
  } else if(meaning instanceof ArgumentReference) {
    return new View.ArgumentReferenceView(meaning)
  } else {
    return new View.BasicMeaningView(meaning)
  }
  throw new Error("lol")
}

View.SlotView = my.Class({
  constructor: function(options) {
    options = options || {}
    
    this.parent = options.parent
    this.fillerText = options.fillerText || "Drag or type something here."
    this.dropCallback = options.drop
    this.dragoutCallback = options.dragout
    
    this.dom = $("<span class='slot unfilled'></span>")
    View.setObjFor(this.dom, this)
    
    this.reset()
    
    this.dom.click(safeClick(this.click.bind(this)))
    
    View.droppable.droppable(this, this.dom)
  },
  
  toString: function() {
    return "SlotView()"
  },
  
  reset: function() {
    this.dom.text(this.fillerText)
  },
  
  click: function() {
    if(this.child) return
    
    var width = this.dom.width()
  
    this.dom.empty()
    var input = $("<input />").appendTo(this.dom)
    input.css("width", width + "px")
    input.focus()
    // View.patternAutocomplete(input, this, this.reset.bind(this))
    View.patternAutocomplete(input, this, function() { debugger })
  },
  
  dropped: function(child) {
    this.accept(child)
    if(this.dropCallback) this.dropCallback(child)
  },
  
  dragout: function(child, target) {
    if(this.dragoutCallback) this.dragoutCallback(child, target)
  },
  
  accept: function(child) {
    child.setParent(this)
    this.child = child
    
    this.dom.removeClass("unfilled")
    this.dom.empty()
    this.dom.append(child.dom)
    this.dom.droppable("disable")
  },
  
  release: function(child) {
    child.dom.detach()
    delete this.child
    
    this.dom.addClass("unfilled")
    this.dom.text(this.fillerText)
    this.dom.droppable("enable")
  },
})

View.InbetweenSlotView = my.Class({
  constructor: function(options) {
    options = options || {}
    
    this.parent = options.parent
    this.dropCallback = options.drop
    
    this.dom = $("<li class='inbetweener not-editing'></li>")
    View.setObjFor(this.dom, this)
    
    this.buttonDom = $("<div class='insert'>+</div>").appendTo(this.dom)
    
    View.droppable.droppable(this, this.dom)
    
    this.dom.mouseenter(function(ev, source) {
      if(!source) this.isHovering = true
      if(dragging || this.editing) {
        return
      }
      this.hover()
    }.bind(this))
    
    this.dom.mouseleave(function(ev, source) {
      if(!source) this.isHovering = false
        
      if(!this.delayedMouseleave) {
        this.delayedMouseleave = _.debounce(function() {
          this.dom.trigger("mouseleave", "self")
        }.bind(this), 600)
      }
      
      if(source) {
        if(!this.isHovering) {
          this.unhover()
        }
      } else {
        this.delayedMouseleave()
      }
    }.bind(this))
    
    this.dom.click(safeClick(this.click.bind(this)))
    this.buttonDom.click(safeClick(this.click.bind(this)))
  },
  
  toString: function() {
    return "InbetweenSlotView()"
  },
  
  reset: function() {
    this.editing = false
    this.dom.addClass("not-editing")
    this.dom.empty()
    this.dom.css("height", "")
    this.dom.append(this.buttonDom)
  },
  
  // make it look like the mouse is hovering over
  hover: function() {
    this.dom.addClass("hover")
    this.dom.children(".insert").show()
  },
  
  // undoes everything done in hover()
  unhover: function() {
    this.dom.removeClass("hover")
    this.dom.children(".insert").hide()
  },
  
  click: function() {
    if(this.editing) return
    this.editing = true
    this.dom.removeClass("not-editing")
    this.dom.trigger("mouseleave", true /* fake */)
    
    this.unhover()
    
    var input = $("<input style='width: 100%; margin: 5px 0' />").appendTo(this.dom)
    this.dom.css("height", input.outerHeight(true /* includeMargin */) + "px")
    View.patternAutocomplete(input, this, this.reset.bind(this))
    // input.focusout(this.reset.bind(this))
    // input.keydown(function(ev) {
    //   if(ev.keyCode == 13) {
    //     // this.dropped(new View.Dragger({ text: input.val() }))
    //     this.reset()
    //   } else if(ev.keyCode == 27) {
    //     this.reset()
    //   }
    // }.bind(this))
    input.focus()
  },
  
  dropped: function(child) {
    this.accept(child)
    if(this.dropCallback) this.dropCallback(child)
  },
  
  accept: function(child) {
    child.setParent(this)
    this.child = child
    
    this.dom.droppable("disable")
  },
  
  release: function(child) {
    child.dom.detach()
    delete this.child
    
    this.dom.droppable("enable")
  },
})

// options.collection: collection to show
// options.modelToView(model): function returning the view for the given model
// options.viewToModel(model): function returning the model for the given view
View.MultiSlotView = my.Class({
  constructor: function(options) {
    options = options || {}
    
    if(options.parent) this.parent = options.parent
    this.fillerText = options.fillerText || "Drag or type something here."
    if(options.limit) this.limit = options.limit
    
    if("collection" in options) {
      this.collection = options.collection
      this.modelToView = options.modelToView
      this.viewToModel = options.viewToModel
      
      this.models = this.collection.map(function(o) { return o })
      this.views = this.collection.map(function(o) { return options.modelToView(o) })
      
      this.collection.on("add", function(model, collection, options) {
        if(this.models[options.index] == model) return
        
        this.models.splice(options.index, 0, model)
        this.views.splice(options.index, 0, this.modelToView(model))
        this.rebuildDom()
      }, this)
      this.collection.on("remove", function(model, collection, options) {
        if(this.models[options.index] != model) return
        
        this.models.splice(options.index, 1)
        this.views.splice(options.index, 1)
        this.rebuildDom()
      }, this)
    } else {
      this.views = []
    }
    
    this.dom = $("<ul class='multislot'></ul>")
    View.setObjFor(this.dom, this)
    
    this.rebuildDom()
  },
  
  toString: function() {
    return "MultiSlotView()"
  },
  
  // removes all children, recreates the DOM, and adds them back
  rebuildDom: function() {
    // beginning of a new epoch
    delete this.indexAdjustment
    
    // release all the children and clear the DOM
    _.each(this.views, function(v) { v.setParent(null) })
    this.dom.html("")
    
    // rebiuld the DOM
    if(this.views.length == 0) {
      this.dom.css("vertical-align", "baseline")
      this.dom.append(this.makeSlot(0))
    } else if(this.limit && this.views.length >= this.limit) {
      this.dom.css("vertical-align", "middle")
      for(var i in this.views) {
        this.dom.append(this.makeSlot(i, this.views[i]))
      }
    } else {
      this.dom.css("vertical-align", "middle")
      for(var i in this.views) {
        this.dom.append(this.makeInbetweener(i))
        this.dom.append(this.makeSlot(i, this.views[i]))
      }
      this.dom.append(this.makeInbetweener(this.views.length))
    }
  },
  
  // returns the dom
  makeInbetweener: function(index) {
    var isv = new View.InbetweenSlotView({ parent: this, drop: this.makeInsertCallback(index) })
    return isv.dom
  },
  
  // if no child given, makes an empty slot
  // returns the dom
  makeSlot: function(index, child) {
    var sv = new View.SlotView({
      parent: this,
      fillerText: this.fillerText,
      drop: this.makeInsertCallback(index),
      dragout: this.makeRemoveCallback(index)
    })
    
    if(child) {
      sv.accept(child)
    }
    
    var li = $("<li class='content'></li>").append(sv.dom)
    li.mousemove(function(ev, ui) {
      if($(this).prev().length == 0 || $(this).next().length == 0) {
        return
      }
      var margin = 15
      var d1 = Math.abs($(this).prev().offset().top - ev.pageY)
      if(d1 < margin) {
        $(this).prev().trigger("mouseenter", "neighbor" /* source */)
      } else {
        $(this).prev().trigger("mouseleave", "neighbor" /* source */)
      }
      var d2 = Math.abs($(this).next().offset().top - ev.pageY)
      if(d2 < margin) {
        $(this).next().trigger("mouseenter", "neighbor" /* source */)
      } else {
        $(this).next().trigger("mouseleave", "neighbor" /* source */)
      }
    })
    li.mouseleave(function(ev, ui) {
      $(this).prev().mouseleave()
      $(this).next().mouseleave()
    })
    return li
  },
  
  makeInsertCallback: function(i) {
    return function(child) { this.insertChild(child, this._adjustIndex(i)) }.bind(this)
  },
  
  makeRemoveCallback: function(i) {
    return function(child, target) { this.removeChild(child, this._adjustIndex(i), target) }.bind(this)
  },
  
  _adjustIndex: function(i) {
    if(("indexAdjustment" in this) && i > this.indexAdjustment) {
      return i - 1
    }
    return i
  },
  
  insertChild: function(child, index) {
    this.views.splice(index, 0, child)
    
    if(this.collection) {
      this.models.splice(index, 0, this.viewToModel(child))
      this.collection.add(this.viewToModel(child), { at: index })
    }
    
    // rebiuld the DOM!
    this.rebuildDom()
  },
  
  removeChild: function(child, index, target) {
    child.dom.detach()
    
    this.views.splice(index, 1)
    
    if(this.collection) {
      this.models.splice(index, 1)
      this.collection.remove(this.collection.at(index))
    }
    
    // only rebuild the DOM if an insert isn't coming immediately afterward
    if(target.parent == this) {
      this.indexAdjustment = index
    } else {
      this.rebuildDom()
    }
  },
})

View.BasicMeaningView = my.Class({
  constructor: function(meaning, options) {
    options || (options = {})
    
    this.meaning = this.model = meaning
    if(options.parent) this.parent = options.parent
    
    this.dom = $("<div class='bubble'></div>")
    this.representationDom = $("<div class='representation'></div>").appendTo(this.dom)
    View.setObjFor(this.dom, this)
    
    this.dom.css("font-family", "monospace")
    
    this.meaning.on("change", this.render, this)
    
    View.draggable.draggable(this, this.dom, { handle: ".representation" })
    
    this.render()
  },
  
  render: function() {
    this.representationDom.empty()
    this.representationDom.text(this.meaning.getValue())
  },
})
View.draggable.decorate(View.BasicMeaningView)

View.ArgumentReferenceView = my.Class({
  constructor: function(reference, options) {
    options || (options = {})
    
    this.reference = this.model = reference
    if(options.parent) this.parent = options.parent
    
    this.dom = $("<div class='bubble reference'></div>")
    this.representationDom = $("<div class='representation'></div>").appendTo(this.dom)
    View.setObjFor(this.dom, this)
    
    this.reference.on("change", this.render, this)
    
    View.draggable.draggable(this, this.dom, { handle: ".representation" })
    
    this.render()
  },
  
  render: function() {
    this.representationDom.empty()
    this.representationDom.text(this.reference.get("name"))
  },
})
View.draggable.decorate(View.ArgumentReferenceView)

View.InvocationView = my.Class({
  constructor: function(invocation, options) {
    options = options || {}
    
    this.invocation = this.model = invocation
    this.parent = options.parent
    this.slotViews = {}
    
    this.dom = $("<div class='bubble'></div>")
    this.representationDom = $("<div class='representation'></div>").appendTo(this.dom)
    this.meaningDom = $("<div class='meaning'></div>").appendTo(this.dom)
    View.setObjFor(this.dom, this)
    
    this.invocation.on("change:representationIndex", this.representationsChanged, this)
    this.invocation.getPattern().on("change:representations", this.representationsChanged, this)
    
    View.draggable.draggable(this, this.dom, { handle: ".representation" })
    
    this.renderRepresentation()
    
    this.representationDom.bind('contextmenu', safeClick(function(e) {
      this.toggleSource()
      return false
    }.bind(this)))
    this.representationDom.click(safeClick(function(e, ui) {
      alert('clicked!')
      var compiled = this.compile()
      // console.log(new Context([compiled], [new Env()]).run())
      console.log(new Context([compiled], [new Env()]).slowRun())
      // $("#debugger").html("").append(new Context([compiled], [new Env()]).debugDom())
    }.bind(this)))
  },
  
  representationsChanged: function() {
    this.renderRepresentation()
  },
  
  meaningChanged: function() {
    this.stopExecution()
    this.renderMeaning()
  },
  
  stopExecution: function() {
  },
  
  isEditing: function() {
    return !this.meaningDom.is(":hidden")
  },
  
  setInteractive: function(val) {
    this.interactive = val
    if(val) {
      this.dom.draggable("enable")
    } else {
      this.dom.draggable("disable")
    }
  },
  
  toggleSource: function() {
    if(this.isEditing()) {
      this.renderRepresentation()
    } else {
      this.renderEditableRepresentation()
    }
    this.renderMeaningIfNecessary()
    
    this.dom.toggleClass("editing")
    this.representationDom.toggleClass("editing")
    this.meaningDom.animate(
      {
        "height" : "toggle",
        "padding-top" : "toggle",
        "padding-bottom" : "toggle"
      },
      { duration: 300 }
    )
  },
  
  _clearRepresentationDom: function() {
    for(var i in this.slotViews) {
      this.slotViews[i].dom.detach()
    }
    this.representationDom.empty()
  },
  
  renderRepresentation: function() {
    this._clearRepresentationDom()
    
    var pattern = this.invocation.getPattern()
    var repr = this.invocation.getCurrentTemplate()
    for(var i in repr.components) {
      var c = repr.components[i]
      if("text" in c) {
        this.representationDom.append(c.text)
      } else if("parameter" in c) {
        var arg = pattern.getArgument(c.parameter)
        this.representationDom.append(this._slotView(arg).dom)
      }
    }
  },
  
  renderEditableRepresentation: function() {
    this.renderRepresentation()
  },
  
  renderMeaningIfNecessary: function() {
    if(!this.renderedMeaning) {
      this.renderMeaning()
      this.renderedMeaning = true
    }
  },
  
  renderMeaning: function() {
    this.meaningDom.empty()
    
    var pattern = this.invocation.getPattern()
    
    if("native_meaning" in pattern) {
      var params = this.invocation.getCurrentTemplate().parameters
      if(params.length > 0) {
        var paramsDom = $("<div>Variables: </div>").appendTo(this.meaningDom)
        for(var i in params) {
          var param = pattern.getArgument(params[i])
          paramsDom.append(new View.ArgumentReferenceView(param).dom)
        }
        paramsDom.append("<hr />")
      }
      
      this.meaningMSV = new View.MultiSlotView({
        collection: pattern.native_meaning,
        modelToView: function(m) { return View.viewForMeaning(m) },
        viewToModel: function(v) { return v.model }
      })
      this.meaningDom.append(this.meaningMSV.dom)
    } else if("javascript_meaning" in pattern) {
      var meaning = pattern.javascript_meaning
      $("<textarea></textarea>").appendTo(this.meaningDom).val(meaning).change(function(e) {
        this.invocation.getPattern().set("javascript_meaning", $(e.target).val())
      }.bind(this))
    }
    
    var numCopies = Math.floor(Math.random() * 5) + 1 // XXX lol, obvs
    if(numCopies > 1) {
      var stats = $("<p class='stats'>editing all <span></span> copies. <a href='#'>edit only this copy</a></h3>").appendTo(this.meaningDom)
      stats.children("span").text(numCopies)
      stats.children("a").click(safeClick(function() { alert("sorry! can't do that yet."); return false }))
    }
  },
  
  _slotView: function(param) {
    var name = param.get("name")
    if(name in this.slotViews) {
      return this.slotViews[name]
    }
    // TODO: make a collection of the params and use that
    var svOpts = {
      fillerText: name,
      collection: this.invocation.argumentValue(param.get("name")),
      modelToView: function(m) { return View.viewForMeaning(m) },
      viewToModel: function(v) { return v.model }
    }
    
    if(param.get("type") != "instructions") {
      svOpts.limit = 1
    }
    
    return this.slotViews[name] = new View.MultiSlotView(svOpts)
  },
  
  compile: function() {
    var compiled
    var pattern = this.invocation.getPattern()
    
    if(this.renderedMeaning && "native_meaning" in pattern) {
      compiled = [this.invocation.compile()]
      
      /*
      var args = _.inject(this.arguments, function(args, mc, name) {
        args[name] = mc.compile()
        return args
      }, {})
      return new VM.ICall(this.getPattern().compile(), args)
      */
    } else {
      compiled = [this.invocation.compile()]
    }
    
    var before = new VM.IJavascript(function() { flash(this.representationDom, "green"); this.dom.addClass("active") }.bind(this), true /* noSave */)
    var after = new VM.IJavascript(function() { this.dom.removeClass("active") }.bind(this), true /* noSave */)
    
    return [before].concat(compiled.concat([after]))
  }
})
View.draggable.decorate(View.InvocationView)

View.TrashView = my.Class({
  constructor: function(options) {
    options = options || {}
    
    this.dom = $("<div class='trash'>TRASH</div>")
    View.setObjFor(this.dom, this)
    
    View.droppable.droppable(this, this.dom, { tolerance: "pointer" })
  },
  
  toString: function() {
    return "TrashView()"
  },
  
  dropped: function(child) {
    this.accept(child)
  },
  
  accept: function(child) {
    child.setParent(null)
  },
})

View.BubbleBlower = my.Class({
  // generator: function which takes a parent and returns a view (with that parent) to replace the one that was dragged away
  constructor: function(generator, options) {
    options || (options = {})
    
    this.generator = generator
    
    this.dom = $("<div style='display: inline-block'></div>")
    View.setObjFor(this.dom, this)
    
    this.respawn()
  },
  
  respawn: function() {
    this.dom.append(this.generator(this).dom)
  },
  
  dragout: function(child, target) {
  },

  release: function(child) {
    child.dom.detach()
    this.respawn()
  },
})

View.HappyTextbox = my.Class({
  constructor: function(options) {
    options || (options = {})
    
    this.dom = $("<div></div>")
    View.setObjFor(this.dom, this)
    
    this.setText(options.text || "")
    this.cursorPosition = 0
    
    this._resetText()
  },
  
  setText: function(text) {
    this.text = text
    this._resetText()
  },
  
  insertText: function(text) {
    this.setText(this.text.slice(0, this.cursorPosition) + text + this.text.slice(this.cursorPosition))
    this.setCursorPosition(this.cursorPosition + text.length)
  },
  
  appendText: function(text) {
    this.setText(this.text + text)
  },
  
  setCursorPosition: function(pos) {
    this.cursorPosition = pos
    this._resetText()
  },
  
  characterAtCursor: function() {
    return this.text[this.cursorPosition]
  },
  
  _resetText: function() {
    var cursor = $("<div style='display: inline-block; width: 2px; margin: 0 1px; height: 20px; vertical-align: middle; background: red' />")
    this.dom.empty()
    this.dom.append($("<span />").text(this.text.slice(0, this.cursorPosition)))
    this.dom.append(cursor)
    this.dom.append($("<span />").text(this.text.slice(this.cursorPosition)))
  },
})

</script>
<script type="text/javascript">

var Patterns = new PatternCollection
var Globals = {}

$(function() {
  Globals.happyInput = new View.HappyTextbox({ text: "One, two, three, four, five." })
  Globals.happyOutput = new View.HappyTextbox()
  
  var table = $("<table style='width: 80%' />").appendTo($("body"))
  $("<tr><th>Input</th><th>Output</th></tr>").appendTo(table)
  var row = $("<tr />").appendTo(table)
  Globals.happyInput.dom.appendTo($("<td style='width: 50%' />").appendTo(row))
  Globals.happyOutput.dom.appendTo($("<td style='width: 50%' />").appendTo(row))
  
  // return
  // Patterns.fetch({
  //   success: function() {
      
      $("body").append(new View.TrashView().dom)
      
      // Patterns.each(function(p) {
      //   p.templates.each(function(t, i) {
      //     $("body").append(new View.InvocationView(new Invocation({ pattern: p.id, representationIndex: i })).dom)
      //   })
      // })
      
      // $("body").append(new View.InvocationView(new Invocation({ pattern: 136 })).dom)
      // $("body").append(new View.InvocationView(new Invocation({ pattern: 161 })).dom)
      // $("body").append(new View.InvocationView(new Invocation({ pattern: 161, representationIndex: 1 })).dom)
      // $("body").append(new View.InvocationView(new Invocation({ pattern: 161 })).dom)
      
      // $("body").append(new View.InvocationView(new Invocation({ pattern: 134 })).dom)
      // var pattern = Patterns.get(134)
      // pattern.set("javascript_meaning", "vm.continuation(env.lookup('message'), function(vals) { setTimeout(function() { alert(vals[0]) }, 230) })")
      
      var add = function(patternAttributes) {
        var pattern = new Pattern(patternAttributes)
        Patterns.add(pattern)
        $("body").append(new View.BubbleBlower(function(parent) { return new View.InvocationView(new Invocation({ pattern: pattern.cid }), { parent: parent }) }).dom)
        return pattern.cid
      }
      add({
        representations: [{ template: "debug" }],
        arguments: [],
        javascript_meaning: "alert('debug')",
      })
      add({
        representations: [{ template: "[left number] &plus; [right number]" }],
        arguments: [{ name: "left number" }, { name: "right number" }],
        javascript_meaning: "vm.continuation(env.lookup('left number'), env.lookup('right number'), function(vals) { return vals[0] + vals[1] })",
      })
      add({
        representations: [{ template: "[left number] &minus; [right number]" }, { template: "[left number] - [right number]" }],
        arguments: [{ name: "left number" }, { name: "right number" }],
        javascript_meaning: "vm.continuation(env.lookup('left number'), env.lookup('right number'), function(vals) { return vals[0] - vals[1] })",
      })
      add({
        representations: [{ template: "[left number] &times; [right number]" }, { template: "[left number] * [right number]" }],
        arguments: [{ name: "left number" }, { name: "right number" }],
        javascript_meaning: "vm.continuation(env.lookup('left number'), env.lookup('right number'), function(vals) { return vals[0] * vals[1] })",
      })
      add({
        representations: [{ template: "[left number] &divide; [right number]" }, { template: "[left number] / [right number]" }],
        arguments: [{ name: "left number" }, { name: "right number" }],
        javascript_meaning: "vm.continuation(env.lookup('left number'), env.lookup('right number'), function(vals) { return vals[0] / vals[1] })",
      })
      add({
        representations: [{ template: "[left number] % [right number]" }, { template: "[left number] mod [right number]" }],
        arguments: [{ name: "left number" }, { name: "right number" }],
        javascript_meaning: "vm.continuation(env.lookup('left number'), env.lookup('right number'), function(vals) { return vals[0] % vals[1] })",
      })
      add({
        representations: [{ template: "[left number] &lt; [right number]" }],
        arguments: [{ name: "left number" }, { name: "right number" }],
        javascript_meaning: "vm.continuation(env.lookup('left number'), env.lookup('right number'), function(vals) { return vals[0] < vals[1] })",
      })
      add({
        representations: [{ template: "[left number] &le; [right number]" }, { template: "[left number] &lt;= [right number]" }],
        arguments: [{ name: "left number" }, { name: "right number" }],
        javascript_meaning: "vm.continuation(env.lookup('left number'), env.lookup('right number'), function(vals) { return vals[0] <= vals[1] })",
      })
      add({
        representations: [{ template: "[left number] == [right number]" }, { template: "[left number] equals [right number]" }],
        arguments: [{ name: "left number" }, { name: "right number" }],
        javascript_meaning: "vm.continuation(env.lookup('left number'), env.lookup('right number'), function(vals) { return vals[0] == vals[1] })",
      })
      add({
        representations: [{ template: "[left number] &ge; [right number]" }, { template: "[left number] &gt;= [right number]" }],
        arguments: [{ name: "left number" }, { name: "right number" }],
        javascript_meaning: "vm.continuation(env.lookup('left number'), env.lookup('right number'), function(vals) { return vals[0] >= vals[1] })",
      })
      add({
        representations: [{ template: "[left number] &gt; [right number]" }],
        arguments: [{ name: "left number" }, { name: "right number" }],
        javascript_meaning: "vm.continuation(env.lookup('left number'), env.lookup('right number'), function(vals) { return vals[0] > vals[1] })",
      })
      add({
        representations: [{ template: "[left number] &ne; [right number]" }, { template: "[left number] != [right number]" }],
        arguments: [{ name: "left number" }, { name: "right number" }],
        javascript_meaning: "vm.continuation(env.lookup('left number'), env.lookup('right number'), function(vals) { return vals[0] != vals[1] })",
      })
      add({
        representations: [{ template: "-[number]" }],
        arguments: [{ name: "number" }],
        javascript_meaning: "vm.continuation(env.lookup('number'), function(vals) { return -vals[0] })",
      })
      var logicalNegationPattern = add({
        representations: [{ template: "![boolean]" }],
        arguments: [{ name: "boolean" }],
        javascript_meaning: "vm.continuation(env.lookup('boolean'), function(vals) { return !vals[0] })",
      })
      add({
        representations: [{ template: "[left boolean] and [right boolean]" }, { template: "[left boolean] &amp;&amp; [right boolean]" }],
        arguments: [{ name: "left boolean" }, { name: "right boolean" }],
        javascript_meaning: "vm.continuation(env.lookup('left boolean'), env.lookup('right boolean'), function(vals) { return vals[0] && vals[1] })",
      })
      add({
        representations: [{ template: "[left boolean] or [right boolean]" }, { template: "[left boolean] || [right boolean]" }],
        arguments: [{ name: "left boolean" }, { name: "right boolean" }],
        javascript_meaning: "vm.continuation(env.lookup('left boolean'), env.lookup('right boolean'), function(vals) { return vals[0] || vals[1] })",
      })
      add({
        representations: [{ template: "[condition] ? [value if true] : [value if false]" }, { template: "[value if true] if [condition] else [value if false]" }],
        arguments: [{ name: "condition" }, { name: "value if true" }, { name: "value if false" }],
        javascript_meaning: "vm.continuation(env.lookup('condition'), function(vals) { vm.delegate(vals[0] ? env.lookup('value if true') : env.lookup('value if false')) })",
      })
      add({
        representations: [{ template: "[string 1] + [string 2]" }],
        arguments: [{ name: "string 1" }, { name: "string 2" }],
        javascript_meaning: "vm.continuation(env.lookup('string 1'), env.lookup('string 2'), function(vals) { return vals[0] + vals[1] })",
      })
      add({
        representations: [{ template: "[string] as a floating point number" }],
        arguments: [{ name: "string" }],
        javascript_meaning: "vm.continuation(env.lookup('string'), function(vals) { return parseFloat(vals[0]) })",
      })
      add({
        representations: [{ template: "[string] as an integer" }],
        arguments: [{ name: "string" }],
        javascript_meaning: "vm.continuation(env.lookup('string'), function(vals) { return parseInt(vals[0]) })",
      })
      add({
        representations: [{ template: "[number] is a valid number" }],
        arguments: [{ name: "number" }],
        javascript_meaning: "vm.continuation(env.lookup('number'), function(vals) { return !isNaN(vals[0]) })",
      })
      add({
        representations: [{ template: "[number] as a string" }],
        arguments: [{ name: "number" }],
        javascript_meaning: "vm.continuation(env.lookup('number'), function(vals) { return '' + vals[0] })",
      })
      add({
        representations: [{ template: "new object" }],
        arguments: [],
        javascript_meaning: "return {}",
      })
      add({
        representations: [{ template: "keys of [object]" }],
        arguments: [{ name: "object" }],
        javascript_meaning: "vm.continuation(env.lookup('object'), function(vals) { return _.keys(vals[0]) })",
      })
      add({
        representations: [{ template: "Set the value of [key] in [object] to [value]." }],
        arguments: [{ name: "object" }, { name: "key" }, { name: "value" }],
        javascript_meaning: "vm.continuation(env.lookup('object'), env.lookup('key'), env.lookup('value'), function(vals) { return vals[0][vals[1]] = vals[2] })",
      })
      add({
        representations: [{ template: "value of [key] in [object]" }],
        arguments: [{ name: "object" }, { name: "key" }],
        javascript_meaning: "vm.continuation(env.lookup('object'), env.lookup('key'), function(vals) { return vals[0][vals[1]] })",
      })
      add({
        representations: [{ template: "remove value for [key] in [object]" }],
        arguments: [{ name: "object" }, { name: "key" }],
        javascript_meaning: "vm.continuation(env.lookup('object'), env.lookup('key'), function(vals) { delete vals[0][vals[1]] })",
      })
      add({
        representations: [{ template: "new array" }],
        arguments: [],
        javascript_meaning: "return []",
      })
      add({
        representations: [{ template: "number of items in [array]" }],
        arguments: [{ name: "array" }],
        javascript_meaning: "vm.continuation(env.lookup('array'), function(vals) { return vals[0].length })",
      })
      add({
        representations: [{ template: "set value of [array] at index [index] to [value]" }],
        arguments: [{ name: "array" }, { name: "index" }, { name: "value" }],
        javascript_meaning: "vm.continuation(env.lookup('array'), env.lookup('index'), env.lookup('value'), function(vals) { return vals[0][vals[1]] = vals[2] })",
      })
      add({
        representations: [{ template: "value of [array] at index [index]" }],
        arguments: [{ name: "array" }, { name: "index" }],
        javascript_meaning: "vm.continuation(env.lookup('array'), env.lookup('index'), function(vals) { return vals[0][vals[1]] })",
      })
      add({
        representations: [{ template: "append [value] to [array]" }],
        arguments: [{ name: "array" }, { name: "value" }],
        javascript_meaning: "vm.continuation(env.lookup('array'), env.lookup('value'), function(vals) { vals[0].push(vals[1]); return vals[1] })",
      })
      var loopPattern = add({
        representations: [{ template: "loop {<br />[actions]<br />}" }],
        arguments: [{ name: "actions", type: "instructions" }],
        javascript_meaning: "vm.beginLoop(); var f = function() { vm.continuation(env.lookup('actions'), f) }; f()",
      })
      var breakPattern = add({
        representations: [{ template: "Break." }],
        arguments: [],
        javascript_meaning: "vm.breakLoop()",
      })
      var ifPattern = add({
        representations: [{ template: "if([condition]) {<br />[actions]<br />}" }],
        arguments: [{ name: "condition" }, { name: "actions", type: "instructions" }],
        javascript_meaning: "vm.continuation(env.lookup('condition'), function(vals) { if(vals[0]) { vm.delegate(env.lookup('actions')) } })",
      })
      add({
        representations: [{ template: "if([condition]) {<br />[actions if true]<br />} else {<br />[actions if false]<br />}" }],
        arguments: [{ name: "condition" }, { name: "actions if true", type: "instructions" }, { name: "actions if false", type: "instructions" }],
        javascript_meaning: "vm.continuation(env.lookup('condition'), function(vals) { vm.delegate(vals[0] ? env.lookup('actions if true') : env.lookup('actions if false')) })",
      })
      add({
        representations: [{ template: "maybe" }],
        arguments: [],
        javascript_meaning: "return Math.random() > 0.5",
      })
      add({
        representations: [{ template: "while([condition]) {<br />[actions]<br />}" }],
        arguments: [{ name: "condition" }, { name: "actions", type: "instructions" }],
        native_meaning: [
          {
            invocation: {
              pattern: loopPattern,
              arguments: {
                actions: [
                  {
                    invocation: {
                      pattern: ifPattern,
                      arguments: {
                        condition: {
                          invocation: {
                            pattern: logicalNegationPattern,
                            arguments: {
                              boolean: { reference: { name: "condition" } }
                            }
                          }
                        },
                        actions: {
                          invocation: { pattern: breakPattern }
                        }
                      }
                    }
                  },
                  { reference: { name: "actions" } }
                ]
              }
            }
          }
        ],
      })
      add({
        representations: [{ template: "Set value of [variable name] to [value]." }],
        arguments: [{ name: "variable name" }, { name: "value" }],
        javascript_meaning: "vm.continuation(env.lookup('variable name'), env.lookup('value'), function(vals) { vm.envs[1].set(vals[0], vals[1]); return vals[1] })",
      })
      add({
        representations: [{ template: "value of [variable name]" }],
        arguments: [{ name: "variable name" }],
        javascript_meaning: "vm.continuation(env.lookup('variable name'), function(vals) { return vm.envs[1].lookup(vals[0]) })",
      })
      add({
        representations: [{ template: "Show a popup displaying [value]." }],
        arguments: [{ name: "value" }],
        javascript_meaning: "vm.continuation(env.lookup('value'), function(vals) { alert(myToString(vals[0])) })",
      })
      
      // CURSORS
      add({
        representations: [{ template: "input cursor" }],
        arguments: [],
        javascript_meaning: "return Globals.happyInput",
      })
      add({
        representations: [{ template: "output cursor" }],
        arguments: [],
        javascript_meaning: "return Globals.happyOutput",
      })
      add({
        representations: [{ template: "input length" }],
        arguments: [],
        javascript_meaning: "return Globals.happyInput.text.length",
      })
      add({
        representations: [{ template: "output length" }],
        arguments: [],
        javascript_meaning: "return Globals.happyInput.text.length",
      })
      add({
        representations: [{ template: "character at [cursor]" }],
        arguments: [{ name: "cursor" }],
        javascript_meaning: "vm.continuation(env.lookup('cursor'), function(vals) { return vals[0].characterAtCursor() })",
      })
      add({
        representations: [{ template: "position of [cursor]" }],
        arguments: [{ name: "cursor" }],
        javascript_meaning: "vm.continuation(env.lookup('cursor'), function(vals) { return vals[0].cursorPosition })",
      })
      add({
        representations: [{ template: "insert [text] at [cursor]" }],
        arguments: [{ name: "cursor" }, { name: "text" }],
        javascript_meaning: "vm.continuation(env.lookup('cursor'), env.lookup('text'), function(vals) { vals[0].insertText(vals[1]) })",
      })
      add({
        representations: [{ template: "set position of [cursor] to [position]" }],
        arguments: [{ name: "cursor" }, { name: "position" }],
        javascript_meaning: "vm.continuation(env.lookup('cursor'), env.lookup('position'), function(vals) { vals[0].setCursorPosition(vals[1]) })",
      })
      
      // USER CODE
      add({
        representations: [{ template: "My Code" }],
        arguments: [],
        native_meaning: [],
      })
      
      // var addPattern = new Pattern({
      //   representations: [{ template: "[left number] + [right number]" }],
      //   arguments: [{ name: "left number" }, { name: "right number" }],
      //   javascript_meaning: "vm.continuation(env.lookup('left number'), env.lookup('right number'), function(vals) { return vals[0] + vals[1] })",
      // })
      // var invocation = new Invocation({
      //   pattern: addPattern,
      //   arguments: { "left number" : { number: 4 }, "right number" : { number: 2 } }
      // })
      // $("body").append(new View.InvocationView(invocation).dom)
      
      // var invocation2 = new Invocation({
      //   pattern: addPattern,
      //   arguments: { "left number" : { number: 4 }, "right number" : { number: 2 } }
      // })
      // $("body").append(new View.InvocationView(invocation2).dom)
      // for(var i = 0; i < 10; i++) {
      //   $("body").append(new View.BasicMeaningView(new NumberMeaning({ number: i })).dom)
      // }
      
      $("body").append("<div id='debugger'></div>")
      
  //   }
  // })
})


</script>
<script type="text/javascript">


///// MACHINE!!!!! ////////

var VM = {}

VM.INamedReference = my.Class({
  constructor: function(name) { this.name = name },
  toString: function() { return "Reference: " + this.name },
})

VM.IPushEnv = my.Class({
  constructor: function(env) { this.env = env },
  toString: function() { return "Push Env" },
})

VM.IPopEnv = my.Class({
  constructor: function() { this.runOnUnwind = true },
  toString: function() { return "Pop Env" },
})

VM.LoopMarker = my.Class({
  toString: function() { return "Loop Marker" },
})

function myToString(v) {
  if(typeof(v) === "string") {
    return "\"" + v + "\""
  } else if(typeof(v) === "number" || typeof(v) === "boolean" || typeof(v) === "function") {
    return "" + v
  } else if(v instanceof Array) {
    return "[" + _.map(v, myToString) + "]"
  } else {
    // return "" + v
    return  "{" + _.map(v, function(v, k) { return k + ": " + myToString(v) }).join(", ") + "}"
  }
}

VM.ICall = my.Class({
  constructor: function(frame, args) { this.frame = frame; this.args = args },
  toString: function() { return "Call(frame: [" + this.frame + "]; args: " + myToString(this.args) + ")" },
})

VM.IJavascript = my.Class({
  constructor: function(source, noSave) {
    if(typeof(source) === "string") {
      this.f = eval("(function(vm, env){" + source + "})")
    } else {
      // assume it's a function
      this.f = source
    }
    this.noSave = noSave
  },
  
  toString: function() {
    return "Javascript: " + this.f
  }
})

VM.IClosure = my.Class({
  constructor: function(frame, env) {
    this.frame = frame.slice(0)
    this.frame.unshift(new VM.IPushEnv(env))
    this.frame.push(new VM.IPopEnv())
  },
  
  toString: function() { return "Closure(frame: [" + this.frame + "]; env: " + this.env + ")" },
})

var Env = my.Class({
  // noTraverse: if true, lookup will not check the parent env (defaults to false)
  constructor: function(values, parent, noTraverse) {
    this.values = values || {}
    if(parent) this.parent = parent
    if(noTraverse) this.noTraverse = noTraverse
  },
  
  set: function(name, value) {
    this.values[name] = value
  },
  
  lookup: function(name) {
    if(name in this.values) {
      return this.values[name]
    }
    if(!this.noTraverse && this.parent) {
      return this.parent.lookup(name)
    }
  },
})

var Context = my.Class({
  // keeps a dupe of the frames
  constructor: function(frames, envs) {
    this.frames = _.map(frames, function(f) { return f.slice(0) }) // 2-level clone
    this.envs = envs.slice(0)
  },
  
  runOne: function(instr) {
    if(typeof(instr) === "string" || typeof(instr) === "number" || typeof(instr) === "boolean" || instr instanceof Array)
    {
      this.result = instr
    }
    else if(instr instanceof VM.INamedReference)
    {
      // var val = this.envs[0].lookup(instr.name)
      // if(val instanceof Array) {
        
      // }
      this.frames[0].unshift(this.envs[0].lookup(instr.name))
    }
    else if(instr instanceof VM.IPushEnv)
    {
      this.envs.unshift(instr.env)
    }
    else if(instr instanceof VM.IPopEnv)
    {
      this.envs.shift()
    }
    else if(instr instanceof VM.ICall)
    {
      var parentEnv = this.envs[0]
      var env = new Env(_.inject(instr.args, function(env, frames, name) {
        if(!(frames instanceof Array)) {
          alert("encapsulated something other than an array", frames)
          alert("encapsulated something other than an array")
        }
        env[name] = new VM.IClosure(frames, parentEnv) // TODO: also save the frame so that break and return can work
        return env
      }, {}))
      var frame = instr.frame.slice(0)
      frame.push(new VM.IPopEnv)
      this.frames.unshift(frame)
      this.envs.unshift(env)
    }
    else if(instr instanceof VM.IClosure)
    {
      delete this.result
      this.frames = [instr.frame.slice(0)].concat(this.frames)
    }
    else if(instr instanceof VM.IJavascript)
    {
      var result
      try {
        result = instr.f(this, this.envs[0])
      } catch(e) {
        console.log("exception", e.toString(), e)
        alert("exception!")
      }
      if(!instr.noSave) {
        this.result = result
      }
    }
    else
    {
      console.log("unrecognized instruction", instr)
      throw new Error("unrecognized instruction")
    }
  },
  
  slowRun: function() {
    var instr = this._shift()
    if(typeof(instr) !== "undefined") {
      setTimeout(function() {
        this.runOne(instr)
        this.slowRun()
      }.bind(this), 1)
    } else {
      var result = this.result
      delete this.result
    }
  },
  
  run: function() {
    while(true) {
      var instr = this._shift()
      if(typeof(instr) !== "undefined") {
        this.runOne(instr)
      } else {
        var result = this.result
        delete this.result
        return result
      }
    }
  },
  
  // removes and returns the next scheduled instruction
  _shift: function() {
    while(this.frames.length > 0) {
      if(this.frames[0].length > 0) {
        return this.frames[0].shift()
      } else {
        this.frames.shift()
      }
    }
  },
  
  // call like continuation(frame, frame, frame, ..., c)
  // will execute all the given frames, then call c() with an array of all the results
  continuation: function() {
    var frames = Array.prototype.slice.call(arguments, 0, -1)
    var c = arguments[arguments.length - 1]
    
    var results = []
    
    var newFrames = []
    
    for(var i in frames) {
      newFrames.push(frames[i])
      newFrames.push(new VM.IJavascript(function(vm, env) {
        results.push(vm.result)
      }))
    }
    
    this.frames[0].unshift(new VM.IJavascript(function() { return c(results) }))
    this.frames.unshift(newFrames)
  },
  
  // call like continuation(frame, frame, frame, ...)
  // will execute all the given frames
  delegate: function() {
    var frames = Array.prototype.slice.call(arguments, 0)
    this.frames.unshift(frames)
  },
  
  beginLoop: function() {
    this.frames[0].unshift(new VM.LoopMarker())
  },
  
  breakLoop: function() {
    var saved = []
    
    while(true) {
      var instr = this._shift()
      if(typeof(instr) === "undefined") {
        throw new Error("used 'break' when not inside a loop")
      } else if(instr.runOnUnwind) {
        saved.push(instr)
      } else if(instr instanceof VM.LoopMarker) {
        break
      }
    }
    
    this.frames.unshift(saved)
  },
  
  debugDom: function(done) {
    this.dom = this.dom || $("<div></div>")
    this.dom.html("")
    
    if(done) {
      this.dom.text("Done!")
      return
    }
    
    var table = $("<table></table>").appendTo(this.dom).append("<tr><th>Frames</th><th>Envs</th><th>Return</th></tr>")
    var row = $("<tr></tr>").appendTo(table)
    this.framesDebugDom().appendTo(row)
    this.envsDebugDom().appendTo(row)
    $("<td></td>").text(("result" in this) ? ("" + this.result) : "").appendTo(row)
    
    table.disableSelection()
    table.click(function() {
      var instr = this._shift()
      if(typeof(instr) !== "undefined") {
        this.runOne(instr)
        this.debugDom()
      } else {
        this.debugDom(true)
      }
    }.bind(this))
    
    return this.dom
  },
  
  framesDebugDom: function() {
    var td = $("<td></td>")
    _.each(this.frames.slice(0).reverse(), function(frame) {
      this.frameDebugDom(frame, td)
    }.bind(this))
    return td
  },
  
  frameDebugDom: function(frame, parent) {
    var table = $("<table></table>").appendTo(parent)
    _.each(frame.slice(0).reverse(), function(instr) {
      var row = $("<tr></tr>").appendTo(table)
      $("<td></td>").text("" + instr).appendTo(row)
    })
  },
  
  envsDebugDom: function() {
    var td = $("<td></td>")
    _.each(this.envs.slice(0).reverse(), function(env) {
      this.envDebugDom(env, td)
    }.bind(this))
    return td
  },
  
  envDebugDom: function(env, parent) {
    var table = $("<table></table>").appendTo(parent)
    _.each(env.values, function(value, key) {
      $("<tr></tr>").append($("<th></th>").text(key)).append($("<td></td>").text(myToString(value))).appendTo(table)
    })
    if(env.parent) {
      var row = $("<tr></tr>").appendTo(table)
      this.envDebugDom(env.parent, $("<td colspan='2'></td>").appendTo(row))
    }
  },
})

</script>
